<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900 text-white">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flight Data Visualizer (Dynamic Gyro Arcs)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        #scene-container canvas {
            display: block;
            width: 100%;
            height: 100%;
            outline: none; 
        }
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px;
            border-radius: 50%; background: #22d3ee; cursor: pointer; margin-top: -6px; 
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #4b5563; border-radius: 2px;
        }
    </style>
</head>
<body class="h-full flex flex-col font-sans">

    <header class="bg-gray-800 p-4 shadow-md z-10 relative flex flex-col md:flex-row justify-between items-center gap-4">
        <div>
            <h1 class="text-xl font-bold">Flight Data Visualizer</h1>
            <p class="text-xs text-gray-400 mt-1">
                Required files: <span id="req-files" class="font-mono text-cyan-300"></span>
            </p>
        </div>
        
        <div class="bg-gray-700 p-3 rounded border border-gray-600 flex items-center gap-3">
            <label class="text-sm font-bold text-gray-200">Select Folder:</label>
            <input type="file" id="folder-input" webkitdirectory directory multiple class="block text-xs text-gray-400
              file:mr-2 file:py-2 file:px-4 file:rounded file:border-0
              file:text-sm file:font-semibold file:bg-blue-600 file:text-white
              hover:file:bg-blue-500 cursor-pointer"
            />
        </div>
    </header>

    <div class="bg-gray-700 p-2 flex justify-center gap-4 shadow-lg text-xs md:text-sm flex-wrap z-10 relative border-b border-gray-600 font-mono">
        <div class="flex items-center gap-2">
            <span>Time:</span> <span id="time-display" class="font-bold text-white">0.00</span>s
        </div>
        <div class="text-gray-500">|</div>
        <div class="text-cyan-400">R:<span id="roll-value">0.0</span> P:<span id="pitch-value">0.0</span> Y:<span id="yaw-value">0.0</span></div>
        <div class="text-gray-500">|</div>
        <div class="text-green-400">Pos:<span id="pos-value" class="text-white">0,0,0</span></div>
        <div class="text-gray-500">|</div>
        <div class="text-purple-400">Gyro:<span id="gyro-value" class="text-white">N/A</span></div>
        <div class="text-gray-500">|</div>
        <div class="text-pink-400">Mag:<span id="mag-value" class="text-white">N/A</span></div>
        <div class="text-gray-500">|</div>
        <div class="text-orange-400">Acc:<span id="acc-value" class="text-white">N/A</span></div>
    </div>

    <main class="flex-grow flex-shrink min-h-0 relative">
        <div id="scene-container" class="absolute inset-0"></div>
        
        <div class="absolute top-4 left-4 bg-gray-900 bg-opacity-75 p-3 rounded text-xs pointer-events-none select-none text-white">
            <div class="font-bold mb-2 border-b border-gray-700 pb-1">Legend</div>
            <div class="flex items-center gap-2 mb-1"><span class="w-3 h-3 bg-yellow-400 rounded-full"></span> <span>Body Up</span></div>
            <div class="flex items-center gap-2 mb-1"><span class="w-3 h-3 bg-pink-500 rounded-full"></span> <span>Mag Vector</span></div>
            <div class="flex items-center gap-2 mb-1"><span class="w-3 h-3 bg-orange-400 rounded-full"></span> <span>Acc (Total)</span></div>
            <div class="flex items-center gap-2 mb-1"><span class="w-3 h-3 bg-red-600 rounded-full"></span> <span>Acc X (Fwd)</span></div>
            <div class="flex items-center gap-2 mb-1"><span class="w-3 h-3 bg-green-500 rounded-full"></span> <span>Acc Y (Right)</span></div>
            <div class="flex items-center gap-2 mb-1"><span class="w-3 h-3 bg-cyan-400 rounded-full"></span> <span>Acc Z (Down)</span></div>
            <div class="flex items-center gap-2 mb-1"><span class="w-3 h-3 border border-white" style="border-color: red"></span> <span>Gyro X (Roll Rate)</span></div>
            <div class="flex items-center gap-2 mb-1"><span class="w-3 h-3 border border-white" style="border-color: lime"></span> <span>Gyro Y (Pitch Rate)</span></div>
            <div class="flex items-center gap-2 mb-1"><span class="w-3 h-3 border border-white" style="border-color: cyan"></span> <span>Gyro Z (Yaw Rate)</span></div>
            <div class="flex items-center gap-2 mb-1"><span class="w-3 h-3 bg-cyan-400 rounded-full"></span> <span>Mag Ref (World)</span></div>
            <div class="flex items-center gap-2 mb-1"><span class="w-3 h-3 bg-blue-600 rounded-full"></span> <span>Motor Cmd</span></div>
            <div class="mt-2 text-gray-400 italic">Left Click: Rotate | Scroll: Zoom</div>
        </div>

        <div id="loading-overlay" class="hidden absolute inset-0 bg-gray-900 bg-opacity-80 flex justify-center items-center z-20">
            <div class="text-center">
                <div class="text-2xl font-bold animate-pulse mb-2">Processing Data...</div>
                <div id="loading-status" class="text-sm text-gray-400"></div>
            </div>
        </div>
    </main>

    <footer class="bg-gray-800 p-4 flex flex-col gap-3 shadow-inner z-10 relative">
        <div class="w-full px-4">
            <input type="range" id="time-slider" min="0" max="100" value="0" class="w-full" disabled>
        </div>

        <div class="flex justify-center items-center gap-4">
            <button id="prev-btn" class="bg-gray-600 hover:bg-gray-500 disabled:opacity-50 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded-lg transition-all" disabled>
                &lt;
            </button>
            <button id="play-pause-btn" class="bg-blue-600 hover:bg-blue-500 disabled:opacity-50 disabled:cursor-not-allowed text-white font-bold py-2 px-6 rounded-lg transition-all w-24" disabled>
                Play
            </button>
            <button id="next-btn" class="bg-gray-600 hover:bg-gray-500 disabled:opacity-50 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded-lg transition-all" disabled>
                &gt;
            </button>
            <select id="speed-select" class="bg-gray-700 text-white text-sm rounded p-1">
                <option value="0.1">0.1x</option>
                <option value="1" selected>1.0x</option>
                <option value="5">5.0x</option>
            </select>
            
            <div class="w-px h-6 bg-gray-600 mx-2"></div>

            <label class="flex items-center gap-2 text-white text-sm cursor-pointer select-none">
                <input type="checkbox" id="follow-cam-checkbox" checked class="w-4 h-4 rounded bg-gray-700 border-gray-600 text-blue-600 focus:ring-blue-500 accent-blue-600">
                <span>Follow</span>
            </label>
        </div>
        <div id="status-message" class="text-center text-xs text-gray-400">Waiting for folder upload...</div>
    </footer>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==========================================
        // CONFIGURATION
        // ==========================================
        const FILE_NAMES = {
            ATTITUDE:       'Quat.csv',
            MAG:            'MAG_Corr.csv',
            ACCEL_MEASURED: 'IMU.csv',
            ACCEL_BIAS:     'AccBias.csv',
            POS_ENU:        'Pos.csv',
            GYRO:           'Gyro.csv',
            CONTROL:        'Control.csv'
        };

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let vehicleGroup, quadModel; 
        let magArrowHelper, accArrowHelper;
        let accArrowX, accArrowY, accArrowZ;
        
        // Gyro Container Groups (These hold the dynamic meshes)
        let gyroGroupX, gyroGroupY, gyroGroupZ; 
        let motorArrows = [];
        
        // Data Store
        let flightData = [];
        let magData = [];
        let accData = [];
        let posData = [];
        let gyroData = [];
        let controlData = [];
        
        let tempAccMeas = [];
        let tempAccBias = [];

        // Playback State
        let isPlaying = false;
        let playbackIndex = 0;
        let lastFrameTime = 0;
        let playbackSpeed = 1.0;
        let cameraFollowsDrone = true;

        // Mapping: Physical Motor Index -> CSV Data Index
        // Physical Indices: 0: FR, 1: FL, 2: BR, 3: BL (Based on creation order)
        // CSV Indices: 0, 1, 2, 3 (corresponding to columns 3, 4, 5, 6)
        const MOTOR_MAPPING = [3, 0, 2, 1]; 

        // UI
        const fileInput = document.getElementById('folder-input');
        const statusMsg = document.getElementById('status-message');
        const reqFilesDisplay = document.getElementById('req-files');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingStatus = document.getElementById('loading-status');
        const followCheckbox = document.getElementById('follow-cam-checkbox');
        
        reqFilesDisplay.textContent = Object.values(FILE_NAMES).join(', ');

        // --- 1. Three.js Setup ---
        function initThreeJS() {
            const container = document.getElementById('scene-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            const aspect = container.clientWidth / container.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 10000);
            camera.position.set(.5,.5,.5); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;

            scene.add(new THREE.AmbientLight(0xaaaaaa));
            const dl = new THREE.DirectionalLight(0xffffff, 1);
            dl.position.set(100, 100, 50);
            scene.add(dl);
            
            const grid = new THREE.GridHelper(200, 50, 0x888888, 0x333333);
            scene.add(grid);

            // --- VEHICLE GROUPS ---
            vehicleGroup = new THREE.Group();
            scene.add(vehicleGroup);

            quadModel = new THREE.Group();
            vehicleGroup.add(quadModel); 
            
            // Body & Arms
            quadModel.add(new THREE.Mesh(new THREE.BoxGeometry(1, 0.1, 1), new THREE.MeshStandardMaterial({ color: 0xcccccc })));
            const armGeo = new THREE.BoxGeometry(0.15, 0.05, 2.5);
            const armMat = new THREE.MeshStandardMaterial({ color: 0x999999 });
            const arm1 = new THREE.Mesh(armGeo, armMat); arm1.rotation.y = Math.PI/4;
            const arm2 = new THREE.Mesh(armGeo, armMat); arm2.rotation.y = -Math.PI/4;
            quadModel.add(arm1, arm2);

            // Props
            const propGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.03, 16);
            const frontMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 });
            const backMat = new THREE.MeshStandardMaterial({ color: 0x555555, transparent: true, opacity: 0.8 });
            const d = 1.25 * Math.sin(Math.PI/4) * 1.414;
            
            // Helper to add props quickly
            const addProp = (x, z, mat) => {
                const m = new THREE.Mesh(propGeo, mat);
                m.position.set(x, 0.05, z);
                quadModel.add(m);
            };
            addProp(d, -d, frontMat); addProp(-d, -d, frontMat);
            addProp(d, d, backMat); addProp(-d, d, backMat);
            
            // Motor Arrows
            const arrowDir = new THREE.Vector3(0, 1, 0);
            const arrowCol = 0x0000ff; // Blue
            motorArrows = [];
            const motorPositions = [
                {x: d, z: -d},  // 0: FR
                {x: -d, z: -d}, // 1: FL
                {x: d, z: d},   // 2: BR
                {x: -d, z: d}   // 3: BL
            ];
            motorPositions.forEach(pos => {
                const arrow = new THREE.ArrowHelper(arrowDir, new THREE.Vector3(pos.x, 0.05, pos.z), 0, arrowCol);
                quadModel.add(arrow);
                motorArrows.push(arrow);
            });

            vehicleGroup.scale.set(.1,.1,.1);
            // Standard Vectors
            quadModel.add(new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 1.5, 0xffff00));
            magArrowHelper = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 0, 0xff00ff);
            quadModel.add(magArrowHelper);
            accArrowHelper = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 0, 0xffa500);
            quadModel.add(accArrowHelper);
            
            // Accel Arrows (FRD Frame: X=Fwd, Y=Right, Z=Down) -> ThreeJS (Fwd=-Z, Right=X, Down=-Y)
            let accArrowGroup = new THREE.Group();
            quadModel.add(accArrowGroup);
            accArrowX = new THREE.ArrowHelper(new THREE.Vector3(0,0,-1), new THREE.Vector3(0,0,0), 0, 0xff0000,.05);
            accArrowY = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 0, 0x00ff00,.05);
            accArrowZ = new THREE.ArrowHelper(new THREE.Vector3(0,-1,0), new THREE.Vector3(0,0,0), 0, 0x00ffff,.05);
            accArrowGroup.add(accArrowX, accArrowY, accArrowZ);
            accArrowGroup.position.set(0,.1,0);
            // --- GYRO RINGS SETUP (Groups) ---
            // We create container Groups for alignment. The Mesh inside will be recreated every frame.
            
            // X-Axis Gyro (Roll) -> Red. 
            // Needs to circle the X axis. Default Torus circles Z. Rotate group Y=90.
            gyroGroupX = new THREE.Group();
            quadModel.add(gyroGroupX);

            // Y-Axis Gyro (Pitch) -> Green.
            // Needs to circle the Z axis (Lateral). Default Torus circles Z. No rotation needed.
            gyroGroupY = new THREE.Group();
            gyroGroupY.rotation.y = Math.PI / 2;
            quadModel.add(gyroGroupY);
            
            // Z-Axis Gyro (Yaw) -> Cyan/Blue.
            // Needs to circle the Y axis (Vertical). Default Torus circles Z. Rotate group X=90.
            gyroGroupZ = new THREE.Group();
            gyroGroupZ.rotation.x = Math.PI / 2;
            quadModel.add(gyroGroupZ);

            // --- REFERENCE VECTORS ---
            const refMagVector = new THREE.ArrowHelper(new THREE.Vector3(-0.0346784,-0.892678,-0.449359), new THREE.Vector3(0,0,0), 1.5, 0x00ffff);
            vehicleGroup.add(refMagVector);

            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
            animate();
        }

        // --- 2. Data Processing ---

        function normalizeTime(t) {
            return t / 1000000.0;
        }

        // Added optional startIdx to support generic CSVs or mapped ones
        function parseVectorCSV(text, startIdx) {
            const lines = text.trim().split(/\r?\n/);
            if (lines.length < 1) return [];
            let startRow = /[a-zA-Z]/.test(lines[0]) ? 1 : 0;
            
            // Default detection if startIdx not provided
            let idxX=1, idxY=2, idxZ=3;
            if (startIdx !== undefined) {
                idxX = startIdx; idxY = startIdx+1; idxZ = startIdx+2;
            } else {
                const firstData = lines[startRow].split(',');
                if (firstData.length >= 6) { idxX=3; idxY=4; idxZ=5; } 
            }

            const data = [];
            for(let i=startRow; i<lines.length; i++) {
                const cols = lines[i].split(',').map(Number);
                if(cols.length < 4 || isNaN(cols[idxX])) continue;
                data.push({
                    t: normalizeTime(cols[0]), // Assume time is col 0
                    x: cols[idxX],
                    y: cols[idxY],
                    z: cols[idxZ]
                });
            }
            return data;
        }

        function parseControlCSV(text) {
            const lines = text.trim().split(/\r?\n/);
            if (lines.length < 1) return [];
            let startRow = /[a-zA-Z]/.test(lines[0]) ? 1 : 0;
            
            const data = [];
            for(let i=startRow; i<lines.length; i++) {
                const cols = lines[i].split(',').map(Number);
                // Time(0), Shape(1,2), Data(3,4,5,6)
                if(cols.length < 7 || isNaN(cols[3])) continue;
                data.push({
                    t: normalizeTime(cols[0]),
                    m: [cols[3], cols[4], cols[5], cols[6]]
                });
            }
            return data;
        }

        fileInput.addEventListener('change', async (e) => {
            const files = e.target.files;
            if (!files.length) return;

            loadingOverlay.classList.remove('hidden');
            loadingStatus.textContent = "Scanning files...";

            // Reset Data
            flightData = []; magData = []; tempAccMeas = []; tempAccBias = []; accData = []; posData = []; gyroData = []; controlData = [];

            let promises = [];

            for (let file of files) {
                if (file.name === FILE_NAMES.ATTITUDE) {
                    promises.push(readFile(file).then(text => processAttitude(text)));
                }
                if (file.name === FILE_NAMES.MAG) {
                    promises.push(readFile(file).then(text => { magData = parseVectorCSV(text); }));
                } 
                if (file.name === FILE_NAMES.ACCEL_MEASURED) {
                    promises.push(readFile(file).then(text => { tempAccMeas = parseVectorCSV(text); }));
                } 
                if (file.name === FILE_NAMES.ACCEL_BIAS) {
                    promises.push(readFile(file).then(text => { tempAccBias = parseVectorCSV(text); }));
                } 
                if (file.name === FILE_NAMES.POS_ENU) {
                    promises.push(readFile(file).then(text => { posData = parseVectorCSV(text); }));
                } 
                if (file.name === FILE_NAMES.GYRO) {
                    promises.push(readFile(file).then(text => { gyroData = parseVectorCSV(text); })); 
                }
                if (file.name === FILE_NAMES.CONTROL) {
                    promises.push(readFile(file).then(text => { controlData = parseControlCSV(text); })); 
                }
            }

            await Promise.all(promises);
            processAccelData();
            
            loadingOverlay.classList.add('hidden');
            if (flightData.length > 0) {
                statusMsg.textContent = `Loaded. Frames: ${flightData.length}. Gyro: ${gyroData.length}. Ctrl: ${controlData.length}`;
                initPlayback();
            } else {
                statusMsg.textContent = "Error: No valid Attitude data found.";
            }
        });

        function readFile(file) {
            return new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.readAsText(file);
            });
        }

        function processAttitude(text) {
            const lines = text.trim().split(/\r?\n/);
            if (lines.length < 2) return;
            const headers = lines[0].toLowerCase().split(',').map(h => h.trim());
            
            let idxT = headers.indexOf('time');
            if (idxT === -1) idxT = 0; 

            let idxW = headers.findIndex(h => ['qw','q1','w'].includes(h));
            let idxX = headers.findIndex(h => ['qx','q2','x'].includes(h));
            let idxY = headers.findIndex(h => ['qy','q3','y'].includes(h));
            let idxZ = headers.findIndex(h => ['qz','q4','z'].includes(h));
            
            if (idxW === -1) { idxW=6; idxX=3; idxY=4; idxZ=5; }

            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(',').map(Number);
                if (cols.length < 4 || isNaN(cols[idxW])) continue;

                const q1=cols[idxW], q2=cols[idxX], q3=cols[idxY], q4=cols[idxZ];
                const roll = Math.atan2(2*(q1*q2+q3*q4), 1-2*(q2**2+q3**2)); 
                const pitch = Math.asin(Math.max(-1, Math.min(1, 2*(q1*q3-q4*q2))));
                const yaw = Math.atan2(2*(q1*q4+q2*q3), 1-2*(q3**2+q4**2));

                flightData.push({
                    t: normalizeTime(cols[idxT]),
                    rollDeg: (roll * 180 / Math.PI).toFixed(1),
                    pitchDeg: (pitch * 180 / Math.PI).toFixed(1),
                    yawDeg: (yaw * 180 / Math.PI).toFixed(1),
                    euler: new THREE.Euler(pitch, -yaw, -roll, 'YXZ')
                });
            }
        }

        function processAccelData() {
            if (tempAccMeas.length === 0) return;
            const count = Math.min(tempAccMeas.length, tempAccBias.length);
            if (tempAccBias.length === 0) {
                accData = tempAccMeas;
                return;
            }
            accData = [];
            for(let i=0; i<count; i++) {
                accData.push({
                    t: tempAccMeas[i].t,
                    x: tempAccMeas[i].x + tempAccBias[i].x,
                    y: tempAccMeas[i].y + tempAccBias[i].y,
                    z: tempAccMeas[i].z + tempAccBias[i].z
                });
            }
        }

        function initPlayback() {
            const slider = document.getElementById('time-slider');
            const playBtn = document.getElementById('play-pause-btn');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            
            const t0 = flightData[0].t;
            flightData.forEach(d => d.tRelative = d.t - t0);
            
            slider.disabled = false;
            playBtn.disabled = false;
            prevBtn.disabled = false;
            nextBtn.disabled = false;
            slider.max = flightData.length - 1;
            slider.value = 0;
            playbackIndex = 0;
            updateFrame(0);
        }

        // --- 3. Animation & Updates ---

        function findClosest(dataArr, targetTime) {
            if (!dataArr || dataArr.length === 0) return null;
            return dataArr.reduce((prev, curr) => 
                Math.abs(curr.t - targetTime) < Math.abs(prev.t - targetTime) ? curr : prev
            );
        }

        function updateFrame(index) {
            if (!flightData[index]) return;
            const data = flightData[index];
            
            // Text Updates
            document.getElementById('time-display').textContent = data.t.toFixed(2);
            document.getElementById('roll-value').textContent = data.rollDeg;
            document.getElementById('pitch-value').textContent = data.pitchDeg;
            document.getElementById('yaw-value').textContent = data.yawDeg;

            // 1. Attitude
            if (quadModel) quadModel.setRotationFromEuler(data.euler);

            // 2. Position
            if (posData.length > 0) {
                const pos = findClosest(posData, data.t);
                if (pos) {
                    const newPos = new THREE.Vector3(pos.y, -pos.z, -pos.x); 
                    const prevPos = vehicleGroup.position.clone();
                    vehicleGroup.position.copy(newPos);
                    
                    if (cameraFollowsDrone) {
                        const delta = newPos.clone().sub(prevPos);
                        camera.position.add(delta);
                        controls.target.copy(newPos);
                    }
                    document.getElementById('pos-value').textContent = 
                        `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
                }
            }

            // 3. Vectors
            updateVector(magData, data.t, magArrowHelper, document.getElementById('mag-value'));
            updateVector(accData, data.t, accArrowHelper, document.getElementById('acc-value'));
            updateAccelArrows(accData, data.t);
            
            // 4. Gyro Visualization (Dynamic Arcs)
            updateGyro(gyroData, data.t);
            
            // 5. Motor Control Arrows
            updateMotorArrows(controlData, data.t);
        }

        function updateVector(dataSource, currentTime, arrowObj, textObj) {
            if(!dataSource.length) {
                arrowObj.visible = false;
                return;
            }
            const match = findClosest(dataSource, currentTime);
            if(match) {
                textObj.textContent = `[${match.x.toFixed(2)}, ${match.y.toFixed(2)}, ${match.z.toFixed(2)}]`;
                const dir = new THREE.Vector3(match.y, -match.z, -match.x);
                if (dir.length() > 0.01) {
                    dir.normalize();
                    arrowObj.setDirection(dir);
                    arrowObj.setLength(1.5, 0.4, 0.2);
                    arrowObj.visible = true;
                }
            }
        }

        function updateAccelArrows(dataSource, currentTime) {
            if (!dataSource.length) {
                accArrowX.visible = false;
                accArrowY.visible = false;
                accArrowZ.visible = false;
                document.getElementById('acc-value').textContent = "N/A";
                return;
            }
            const match = findClosest(dataSource, currentTime);
            if (match) {
                document.getElementById('acc-value').textContent = 
                    `[${match.x.toFixed(2)}, ${match.y.toFixed(2)}, ${match.z.toFixed(2)}]`;

                const scale = 0.15; // Scale factor for visualization

                // X (Forward) -> -Z
                accArrowX.visible = true;
                accArrowX.setDirection(new THREE.Vector3(0, 0, match.x >= 0 ? -1 : 1));
                accArrowX.setLength(Math.max(0.001, Math.abs(match.x) * scale), 0.2, 0.1);

                // Y (Right) -> +X
                accArrowY.visible = true;
                accArrowY.setDirection(new THREE.Vector3(match.y >= 0 ? 1 : -1, 0, 0));
                accArrowY.setLength(Math.max(0.001, Math.abs(match.y) * scale), 0.2, 0.1);

                // Z (Down) -> -Y
                accArrowZ.visible = true;
                accArrowZ.setDirection(new THREE.Vector3(0, match.z >= 0 ? -1 : 1, 0));
                accArrowZ.setLength(Math.max(0.001, Math.abs(match.z) * scale), 0.2, 0.1);
            }
        }

        // --- DYNAMIC GYRO ARC LOGIC ---
        function updateDynamicArc(group, value, color) {
            // 1. Clear previous mesh
            while(group.children.length > 0){ 
                const child = group.children[0];
                if(child.geometry) child.geometry.dispose();
                if(child.material) child.material.dispose();
                group.remove(child); 
            }
            value*=1;
            // 2. Threshold check
            if (Math.abs(value) < 0.05) return; // Too small to see

            // 3. Calculate Arc Length (Pie Slice)
            // Scaling: 1 rad/s (approx 57 deg/s) = 45 degrees of arc
            const sensitivity = 0.8; 
            let arcLen = Math.abs(value) * sensitivity;
            if (arcLen > Math.PI * 1.9) arcLen = Math.PI * 1.9; // Max cap just under 360

            // 4. Create Geometry
            // TorusGeometry(radius, tube, radialSegments, tubularSegments, arc)
            const radius = 1.0;
            const tube = 0.05;
            const geo = new THREE.TorusGeometry(radius, tube, 8, 20, arcLen);
            const mat = new THREE.MeshStandardMaterial({ color: color, transparent: true, opacity: 0.8 });
            const mesh = new THREE.Mesh(geo, mat);

            // 5. Handle Direction (CW vs CCW)
            // TorusGeometry creates an arc from angle 0 to arcLen (Counter-Clockwise).
            // If value is Positive (CCW rotation): Arc is perfect (0 to len).
            // If value is Negative (CW rotation): We want it to look like it's going CW. 
            // We rotate the mesh by -arcLen. 
            // Example: Arc is 90 deg. 
            // Pos: Starts at 0, goes to 90.
            // Neg: Rotate start to -90. Goes to 0. Visually looks like a CW trail ending at 0.
            
            if (value < 0) {
                mesh.rotation.z = -arcLen;
            }

            group.add(mesh);
        }

        function updateGyro(dataSource, currentTime) {
            if (!dataSource.length) {
                document.getElementById('gyro-value').textContent = "N/A";
                return;
            }
            const match = findClosest(dataSource, currentTime);
            if (match) {
                document.getElementById('gyro-value').textContent = 
                    `[${match.x.toFixed(2)}, ${match.y.toFixed(2)}, ${match.z.toFixed(2)}]`;
                
                // Update X (Roll) -> Red
                updateDynamicArc(gyroGroupX, -match.x, 0xff0000);
                
                // Update Y (Pitch) -> Green
                updateDynamicArc(gyroGroupY, match.y, 0x00ff00);
                
                // Update Z (Yaw) -> Cyan
                updateDynamicArc(gyroGroupZ, match.z, 0x00ffff);
            }
        }

        function updateMotorArrows(dataSource, currentTime) {
            if (!dataSource.length) {
                motorArrows.forEach(a => a.visible = false);
                return;
            }
            const match = findClosest(dataSource, currentTime);
            if (match) {
                motorArrows.forEach((arrow, i) => {
                    const dataIndex = MOTOR_MAPPING[i];
                    const val = match.m[dataIndex];
                    // Scale arrow. Max length e.g. 1.5 for value 1.0
                    if (val > 0.01) {
                        arrow.visible = true;
                        arrow.setLength(val * 1.5, 0.3, 0.15); 
                    } else {
                        arrow.visible = false;
                    }
                });
            }
        }

        // Event Listeners
        const slider = document.getElementById('time-slider');
        slider.addEventListener('input', (e) => {
            if (isPlaying) togglePlay();
            playbackIndex = parseInt(e.target.value);
            updateFrame(playbackIndex);
        });

        followCheckbox.addEventListener('change', (e) => {
            cameraFollowsDrone = e.target.checked;
        });

        document.getElementById('play-pause-btn').addEventListener('click', togglePlay);
        document.getElementById('prev-btn').addEventListener('click', () => stepFrame(-1));
        document.getElementById('next-btn').addEventListener('click', () => stepFrame(1));
        document.getElementById('speed-select').addEventListener('change', (e) => {
            playbackSpeed = parseFloat(e.target.value);
        });

        function stepFrame(delta) {
            if (isPlaying) togglePlay();
            let newIndex = playbackIndex + delta;
            if (newIndex < 0) newIndex = 0;
            if (newIndex >= flightData.length) newIndex = flightData.length - 1;
            
            playbackIndex = newIndex;
            slider.value = playbackIndex;
            updateFrame(playbackIndex);
        }

        function togglePlay() {
            isPlaying = !isPlaying;
            const btn = document.getElementById('play-pause-btn');
            btn.textContent = isPlaying ? "Pause" : "Play";
            btn.classList.toggle('bg-blue-600');
            btn.classList.toggle('bg-red-600');
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); 

            if (isPlaying && flightData.length > 0) {
                const now = performance.now();
                const dt = now - lastFrameTime;
                const interval = 1000 / (30 * playbackSpeed);

                if (dt > interval) {
                    playbackIndex++;
                    if (playbackIndex >= flightData.length) {
                        playbackIndex = 0;
                        togglePlay();
                        playbackIndex = flightData.length - 1;
                    }
                    slider.value = playbackIndex;
                    updateFrame(playbackIndex);
                    lastFrameTime = now;
                }
            }
            renderer.render(scene, camera);
        }

        initThreeJS();
    </script>
</body>
</html>