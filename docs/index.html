<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900 text-white">
<head>
    <meta charset="UTF-R-8">
    <!-- This is critical for mobile browsers -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAVLink 3D Attitude Visualizer</title>
    <!-- 1. Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Make the canvas fill its container */
        #scene-container canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="h-full flex flex-col font-sans">

    <!-- Header -->
    <header class="bg-gray-800 p-4 shadow-md text-center">
        <h1 class="text-2xl font-bold">MAVLink 3D Visualizer</h1>
    </header>

    <!-- Data Display Bar -->
    <div class="bg-gray-700 p-3 flex justify-center gap-6 shadow-lg text-sm md:text-base flex-wrap">
        <div>Roll: <span id="roll-value" class="font-mono font-bold text-cyan-400">0.00</span>°</div>
        <div>Pitch: <span id="pitch-value" class="font-mono font-bold text-cyan-400">0.00</span>°</div>
        <div>Yaw: <span id="yaw-value" class="font-mono font-bold text-cyan-400">0.00</span>°</div>
    </div>

    <!-- Main Content Area -->
    <main class="flex-grow flex-shrink min-h-0 relative">
        <!-- This container will hold the 3D scene -->
        <div id="scene-container" class="absolute inset-0"></div>
    </main>

    <!-- Footer / Control Bar -->
    <footer class="bg-gray-800 p-4 flex justify-center items-center shadow-inner">
        <button id="connect-button" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-6 rounded-lg transition-all">
            Connect to Quadcopter
        </button>
        <div id="status-message" class="ml-4 text-gray-400"></div>
    </footer>

    <!-- 
      2. Load Libraries as ES Modules
      - three.js: For 3D rendering
      - mavlink-browser: For MAVLink parsing. We use esm.sh as a CDN.
    -->
    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js';
        
        // This is the magic part. We import the MAVLink parser from a CDN.
        // This specific library is an event emitter, which is perfect for this.
        import { MAVLink20Processor } from 'https://esm.sh/mavlink-browser';

        // --- Global Variables ---
        let scene, camera, renderer, quadModel;
        let port, reader, mavlinkParser;

        const connectButton = document.getElementById('connect-button');
        const statusMessage = document.getElementById('status-message');
        const rollValue = document.getElementById('roll-value');
        const pitchValue = document.getElementById('pitch-value');
        const yawValue = document.getElementById('yaw-value');
        const sceneContainer = document.getElementById('scene-container');

        // --- 1. Three.js Scene Setup ---
        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222); // Dark background

            // Camera
            const aspect = sceneContainer.clientWidth / sceneContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 1.5, 3.5); // Position camera to look at the quad
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
            sceneContainer.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xaaaaaa);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
            
            // Add a grid helper to the scene
            const gridHelper = new THREE.GridHelper(10, 10, 0x888888, 0x444444);
            scene.add(gridHelper);

            // Create the Rudimentary Quadcopter Model
            quadModel = new THREE.Group();

            // Body (a flat box)
            const bodyGeo = new THREE.BoxGeometry(1, 0.1, 1);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            quadModel.add(body);

            // Arms (thin boxes)
            const armGeo = new THREE.BoxGeometry(0.15, 0.05, 2.5);
            const armMat = new THREE.MeshStandardMaterial({ color: 0x999999 });
            
            const arm1 = new THREE.Mesh(armGeo, armMat);
            arm1.rotation.y = Math.PI / 4; // 45 degrees
            quadModel.add(arm1);

            const arm2 = new THREE.Mesh(armGeo, armMat);
            arm2.rotation.y = -Math.PI / 4; // -45 degrees
            quadModel.add(arm2);

            // "Propellers" (simple cylinders)
            const propGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.03, 16);
            const propMat = new THREE.MeshStandardMaterial({ color: 0x555555, transparent: true, opacity: 0.8 });
            const frontPropMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 }); // Green for front
            
            // Position props at the end of the arms
            const armLength = 1.25 * Math.sin(Math.PI / 4) * 1.414; // Tuned position
            
            const prop1 = new THREE.Mesh(propGeo, frontPropMat); // Front-Right
            prop1.position.set(armLength, 0.05, -armLength);
            quadModel.add(prop1);

            const prop2 = new THREE.Mesh(propGeo, frontPropMat); // Front-Left
            prop2.position.set(-armLength, 0.05, -armLength);
            quadModel.add(prop2);

            const prop3 = new THREE.Mesh(propGeo, propMat); // Back-Right
            prop3.position.set(armLength, 0.05, armLength);
            quadModel.add(prop3);

            const prop4 = new THREE.Mesh(propGeo, propMat); // Back-Left
            prop4.position.set(-armLength, 0.05, armLength);
            quadModel.add(prop4);

            scene.add(quadModel);

            // Handle window resizing
            window.addEventListener('resize', onWindowResize);
            
            // Start the animation loop
            animate();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            renderer.render(scene, camera);
        }

        // Handle resizing
        function onWindowResize() {
            camera.aspect = sceneContainer.clientWidth / sceneContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
        }

        // --- 2. Web Serial and MAVLink Logic ---

        // Check for Web Serial support
        if (!('serial' in navigator)) {
            statusMessage.textContent = 'Error: Web Serial API not supported. Use Chrome or Edge.';
            connectButton.disabled = true;
            connectButton.classList.add('opacity-50', 'cursor-not-allowed');
        }

        connectButton.addEventListener('click', async () => {
            if (!port) {
                await connectSerial();
            } else {
                await disconnectSerial();
            }
        });

        async function connectSerial() {
            try {
                console.log("Attempting to connect to serial port...");
                // Request user to select a serial port.
                // Providing filters is crucial for mobile browsers to recognize the device.
                port = await navigator.serial.requestPort({ 
                    filters: [
                        // This filter targets the common STMicroelectronics Virtual COM Port.
                        { usbVendorId: 0x0483, usbProductId: 0x5740 } 
                    ]
                });
                
                // Open the port. MAVLink often uses 115200 or 57600 baud.
                await port.open({ baudRate: 57600 }); 

                statusMessage.textContent = 'Connected. Waiting for data...';
                console.log("Serial port connected and opened.");
                connectButton.textContent = 'Disconnect';
                connectButton.classList.remove('bg-blue-600', 'hover:bg-blue-500');
                connectButton.classList.add('bg-red-600', 'hover:bg-red-500');

                // Initialize the MAVLink parser
                // This parser is an EventEmitter, so we can listen for messages.
                mavlinkParser = new MAVLink20Processor();
                mavlinkParser.on('message', handleMavlinkMessage);

                // Start the read loop
                readFromSerial();

            } catch (err) {
                console.error("Connection failed:", err);
                statusMessage.textContent = `Error: ${err.message}`;
            }
        }

        async function disconnectSerial() {
            console.log("Disconnecting from serial port...");
            if (reader) {
                await reader.cancel(); // Stop the read loop
                reader.releaseLock();
                reader = null;
            }
            if (port) {
                await port.close();
                port = null;
            }
            statusMessage.textContent = 'Disconnected';
            connectButton.textContent = 'Connect to Quadcopter';
            connectButton.classList.remove('bg-red-600', 'hover:bg-red-500');
            connectButton.classList.add('bg-blue-600', 'hover:bg-blue-500');
            console.log("Disconnected.");
        }

        async function readFromSerial() {
            while (port && port.readable) {
                reader = port.readable.getReader();
                try {
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) {
                            // Reader has been canceled
                            break;
                        }
                        // console.log("Received raw data chunk:", value);
                        // Feed the incoming data chunks into the parser
                        if (mavlinkParser) {
                            mavlinkParser.parseBuffer(value);
                        }
                    }
                } catch (err) {
                    console.error("Read loop error:", err);
                    statusMessage.textContent = `Read error: ${err.message}`;
                } finally {
                    if (reader) {
                        reader.releaseLock();
                    }
                }
            }
        }

        // --- 3. Data Handling ---

        function handleMavlinkMessage(message) {
            // Log every message received to see what's coming in
            console.log(`Received MAVLink message: ${message._name} (ID: ${message._id})`, message);

            // We are looking for ATTITUDE_QUATERNION (ID #31) from the firmware
            if (message._name === 'ATTITUDE_QUATERNION') {
                statusMessage.textContent = 'Receiving Attitude Data...';

                // 1. Create a quaternion from the incoming MAVLink data (NED frame)
                const nedQuaternion = new THREE.Quaternion(message.q1, message.q2, message.q3, message.q4);

                // 2. Define the transformation from NED to the Three.js world frame (FLU).
                // This is a fixed rotation: -90 degrees around X, then -90 degrees around Z.
                const nedToFlu = new THREE.Quaternion().setFromEuler(new THREE.Euler(-Math.PI / 2, 0, -Math.PI / 2));

                // 3. Apply the transformation to get the final orientation for the model.
                const fluQuaternion = nedQuaternion.clone().premultiply(nedToFlu);

                // Create an Euler object to store the converted angles
                const euler = new THREE.Euler().setFromQuaternion(fluQuaternion, 'XYZ'); // Use 'XYZ' for Roll, Pitch, Yaw

                // Update the 3D model
                update3DModel(fluQuaternion);

                // Update the text display (convert radians to degrees)
                rollValue.textContent = (euler.x * 180 / Math.PI).toFixed(2); // Roll
                pitchValue.textContent = (euler.y * 180 / Math.PI).toFixed(2); // Pitch
                yawValue.textContent = (euler.z * 180 / Math.PI).toFixed(2); // Yaw
            }
        }

        function update3DModel(fluQuaternion) {
            if (quadModel) {
                // Directly apply the correctly transformed quaternion to the model.
                quadModel.setRotationFromQuaternion(fluQuaternion);
            }
        }

        // --- Start Everything ---
        initThreeJS();

    </script>
</body>
</html>
